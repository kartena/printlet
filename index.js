// Generated by CoffeeScript 1.4.0
(function() {
  var Canvas, MM, STATUS_CODES, createServer, fs, get, parse, port, prinlet, render, server, tileJSONPath, _ref, _ref1;

  get = require('get');

  MM = require('modestmaps');

  Canvas = require('canvas');

  module.exports = prinlet = function(tilejson) {
    var projection, providerIndex, providers, tileSize, tmpl;
    providerIndex = 0;
    providers = (function() {
      var _i, _len, _ref, _results;
      _ref = tilejson.tiles;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        tmpl = _ref[_i];
        _results.push(new MM.Template(tmpl));
      }
      return _results;
    })();
    projection = new MM.MercatorProjection(0, MM.deriveTransformation(-Math.PI, Math.PI, 0, 0, Math.PI, Math.PI, 1, 0, -Math.PI, -Math.PI, 0, 1));
    tileSize = 256;
    return function(opt, callback) {
      var canvas, centerCoordinate, checkDone, column, completeRequests, coordinatePoint, ctx, endCoord, getTile, height, lat, lng, location, numRequests, pointCoordinate, row, startCoord, width, zoom, _i, _j, _ref, _ref1, _ref2, _ref3;
      width = opt.width, height = opt.height, zoom = opt.zoom, lng = opt.lng, lat = opt.lat;
      location = new MM.Location(lat, lng);
      canvas = new Canvas(width, height);
      ctx = canvas.getContext('2d');
      centerCoordinate = projection.locationCoordinate(location).zoomTo(zoom);
      pointCoordinate = function(point) {
        var coord;
        coord = centerCoordinate.copy();
        coord.column += (point.x - width / 2) / tileSize;
        coord.row += (point.y - height / 2) / tileSize;
        return coord;
      };
      coordinatePoint = function(coord) {
        var point;
        if (coord.zoom !== zoom) {
          coord = coord.zoomTo(zoom);
        }
        point = new MM.Point(width / 2, height / 2);
        point.x += tileSize * (coord.column - centerCoordinate.column);
        point.y += tileSize * (coord.row - centerCoordinate.row);
        return point;
      };
      numRequests = 0;
      completeRequests = 0;
      checkDone = function() {
        if (completeRequests === numRequests) {
          return callback(void 0, 'image/png', canvas.pngStream());
        }
      };
      getTile = function(c, callback) {
        var url;
        url = providers[providerIndex].getTile(c);
        providerIndex = (providerIndex + 1) % providers.length;
        if (url) {
          numRequests++;
          return new get(url).asBuffer(function(err, data) {
            var img, p;
            if (err != null) {
              return callback("" + url + " error: " + err);
            }
            img = new Canvas.Image();
            img.src = data;
            p = coordinatePoint(c);
            ctx.drawImage(img, p.x, p.y, tileSize, tileSize);
            completeRequests++;
            return checkDone();
          });
        }
      };
      startCoord = pointCoordinate(new MM.Point(0, 0)).container();
      endCoord = pointCoordinate(new MM.Point(width, height)).container();
      for (column = _i = _ref = startCoord.column, _ref1 = endCoord.column; _ref <= _ref1 ? _i <= _ref1 : _i >= _ref1; column = _ref <= _ref1 ? ++_i : --_i) {
        for (row = _j = _ref2 = startCoord.row, _ref3 = endCoord.row; _ref2 <= _ref3 ? _j <= _ref3 : _j >= _ref3; row = _ref2 <= _ref3 ? ++_j : --_j) {
          getTile(new MM.Coordinate(row, column, zoom));
        }
      }
    };
  };

  if (!module.parent) {
    fs = require('fs');
    parse = require('url').parse;
    _ref = require('http'), createServer = _ref.createServer, STATUS_CODES = _ref.STATUS_CODES;
    _ref1 = process.argv.slice(2), port = _ref1[0], tileJSONPath = _ref1[1];
    render = prinlet(JSON.parse(fs.readFileSync(tileJSONPath || 'tile.json')));
    server = createServer(function(req, res) {
      var height, lat, lng, opt, width, zoom, _ref2;
      _ref2 = parse(req.url).pathname.substr(1).split('/'), width = _ref2[0], height = _ref2[1], zoom = _ref2[2], lat = _ref2[3], lng = _ref2[4];
      opt = {
        width: parseInt(width),
        height: parseInt(height),
        zoom: parseInt(zoom),
        lat: parseFloat(lat),
        lng: parseFloat(lng)
      };
      return render(opt, function(err, mime, stream) {
        if (err != null) {
          res.writeHead(500);
          return res.end("" + STATUS_CODES[500] + ": " + err);
        } else {
          res.writeHead(200, {
            'Content-Type': mime
          });
          return stream.pipe(res);
        }
      });
    });
    server.listen(parseInt(port || 4140));
  }

}).call(this);
